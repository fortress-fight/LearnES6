# Learn ES6

# 1 函数的扩展

## 1.1 函数参数的默认值

[DOME1](./html/dome1.js)
```
function fn (x=7,y=7) {
    console.log(x,y);
}
fn() // 7  7
```

### 1.1.1 函数与结构赋值

```
function fn ([x,y=7]) {
    console.log(x, y); // 10 7
}
fn ([10])
// 相当于 var [x,y=7] = [10]
```

但是如果直接使用默认值就不能这么写了

```
function fn ([x,y=7]) {
    console.log(x, y);
}
fn () // Cannot match against 'undefined' or 'null'.
```

相当于 var [x,y=7] 但是没有赋值；
可以使用下面的方式解决，相当于 var [x,y=7] = []
```
function fn ([x,y=7] = []) {
    console.log(x, y); // 10 7
}
fn()
```

### 1.1.2 参数默认值的位置

通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的，除非将这个值手动置为`undefined`(使用null是无效的)


### 1.1.3  函数的length属性

[DOME2](./html/dome2.js)

函数的length属性是传入参数的长度:
```
function fn (a,b,c,d){}
console.log(fn.length); // 4
```
但是在ES6中，如果一个参数存在默认值，那么length就会忽略到这个值，以及以后的参数
```
function fn (a,b=1,c){}
console.log(fn.length); // 1
```

### 1.1.4 应用

可以使用这个方法，抛出缺少参数的提示：

```
function throwIfMissing (){
    throw new Error('Missing parameter');
}
function fn (a = throwIfMissing()) {
    return a
}
fn()
```
并且可以将一个参数设置默认值为 `undefined` 表示这个值可以省略

## 1.2 rest 参数

[DOME3](./html/dome3.js)

ES6引入rest参数（形式为“...变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

```
function fn (first,...nums) {
    for (num of nums) {
        first+=num;
    }
    console.log(nums); // [ 1, 2, 3, 4, 5, 6 ]
    return first
}
console.log(fn (1000,1,2,3,4,5,6)) // 1021
console.log(fn.length); //1
```

注：length 不计算 rest

## 1.3 扩展运算符

扩展运算符（spread）是三个点（...）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。这样就可以将其作为参数使用；

```
function fn (newArr, arr) {
    console.log(...arr); // 1 2 3 4
    console.log([...arr]); // [ 1, 2, 3, 4 ]
    newArr.push(...arr);
}
var oldArr = [];

fn(oldArr, [1,2,3,4])
console.log(oldArr); //  [ 1, 2, 3, 4 ]
```

>注:
> __任何Iterator接口的对象__，都可以用扩展运算符转为真正的数组。

### 1.3.1 实例：

1） 代替apply
apply 的第二个参数是一个数组，将数组中的成员作为参数传入，而使用扩展运算符的就可以将数组转换，这样就可以直接使用了

```
function fn (a,b,c) {
    console.log(a,b,c);// 1 2 3
}
var arr = [1,2,3]
fn(...arr)
```

2） 取最大值

```
var arr = [1,2,1,123,121,12,21];
console.log(Math.max.apply(Math, arr)); // 123
console.log(Math.max(...arr)); // 123
```

3） 合并数组

```
var arr1 = ['a','b','c'],
    arr2 = ['d'],
    arr3 = ['f','g'];

console.log(arr1.concat(arr2, arr3)) //[ 'a', 'b', 'c', 'd', 'f', 'g' ]
console.log([...arr1, ...arr2, ...arr3]); // [ 'a', 'b', 'c', 'd', 'f', 'g' ]
```

4）取出数组第一位

```
var arr = [1,2,3,4]
var [first, ...newArr] = arr;
console.log(first); // 1
console.log(newArr); // [2,3,4]
```

5） 字符串转数组

```
var str = 'hello';
console.log([...str]); //[ 'h', 'e', 'l', 'l', 'o' ]
```

注：上面的写法，有一个重要的好处，那就是能够正确识别32位的Unicode字符。

## 1.4 严格模式
规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。

## 1.5 name 属性

## 1.6 箭头函数

### 1.6.1 箭头函数的基本用法

[DOME4](./html/dome4.js)

```
var f = (num1, num2) => {
    num = num1 + num2*10;
    return num;
}

console.log(f(100,2200)) // 22100

// // 相当于：
// function (num1, num2) {
//     var num = num1 + num2*10;
//     return num;
// }
```

如果只有一个语句,可以简写成：

```
// 只有一条语句
var f = () => '箭头函数简写';

console.log(f()) // 箭头函数简写

var f = (num1,num2) => num1+num2;
console.log(f(1,2)); // 3

```

如果只有一个参数, 还可以简写成
```
var f = v => v;

console.log(f('箭头函数')) // 箭头函数

// 相当于
// var f = function (v) {
//     return v
// }
```

### 1.6.2 箭头函数注意事项

[DOME5](./html/dome5.html)

1. 函数体内的this对象，是指函数定义时所在的执行环境，而不是使用的执行环境；

```
window.id = 'window'
function fn () {
    setTimeout(()=>{
        console.log(this,this.id);
    }, 1000)
};
fn() // window undefined
/**
 *  这里的fn中的this就是window，
 *  而setTimeout中的箭头函数指向fn的内部this，即window
 *  现在我们修改 fn 的执行环境
 */
fn.call({id:'一个新的对象'}) // {id: "一个新的对象"} "一个新的对象"
/**
 * 可以看到定时器中的this依旧是指向fn中的this；
 * 下面是对照组
 */
function fn1() {
    setTimeout(function (){
        console.log(this, this.id);
    }, 2000)
}
fn1.call({id: '一个对照组对象'}) // window 'window'
```

2. 不可以当作构造函数使用，也就是说，不可以使用new命令，否则会抛出一个错误。
[DOME5](./html/dome5.js)

```
var fn = () => {};

var a = new fn()
//fn is not a constructor
```

3. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。

```
var fn = (...arg) => {console.log(arg);} //[ 1, 2, 3, 4 ]
fn(1,2,3,4)
```

4. 不可以使用yield命令，因此箭头函数不能用作Generator函数。







































m
